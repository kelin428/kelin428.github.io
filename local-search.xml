<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>整理常见的Go语言基础</title>
    <link href="/2024/07/28/%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/28/%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="整理面试中常见的Go语言基础"><a href="#整理面试中常见的Go语言基础" class="headerlink" title="整理面试中常见的Go语言基础"></a>整理面试中常见的Go语言基础</h1><h2 id="一、defer"><a href="#一、defer" class="headerlink" title="一、defer"></a>一、defer</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>defer</strong> 是Go中一个重要的关键字，很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。</p><p>没啥好说的，直接上笔试题</p><h4 id="问题1：基本用法"><a href="#问题1：基本用法" class="headerlink" title="问题1：基本用法"></a>问题1：基本用法</h4><p>问：TestDeferOrder函数执行后，输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDeferOrder</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题2：defer与return的关系"><a href="#问题2：defer与return的关系" class="headerlink" title="问题2：defer与return的关系"></a>问题2：defer与return的关系</h4><p>问：TestDeferReturn函数返回值是多少？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDeferReturn</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i++<br>    &#125;()<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题3：defer修改命名返回值"><a href="#问题3：defer修改命名返回值" class="headerlink" title="问题3：defer修改命名返回值"></a>问题3：defer修改命名返回值</h4><p>问：TestDeferNamedReturn函数返回值是多少？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDeferNamedReturn</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i++<br>    &#125;()<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题4：defer与panic的关系"><a href="#问题4：defer与panic的关系" class="headerlink" title="问题4：defer与panic的关系"></a>问题4：defer与panic的关系</h4><p>问：TestDeferPanic函数执行后，输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDeferPanic</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Deferred function executed&quot;</span>)<br>    &#125;()<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurred&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题5：多个defer语句的执行顺序"><a href="#问题5：多个defer语句的执行顺序" class="headerlink" title="问题5：多个defer语句的执行顺序"></a>问题5：多个defer语句的执行顺序</h4><p>问：TestMultipleDefers函数执行后，输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMultipleDefers</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题6：defer与匿名函数"><a href="#问题6：defer与匿名函数" class="headerlink" title="问题6：defer与匿名函数"></a>问题6：defer与匿名函数</h4><p>问：TestDeferAnonymousFunction函数执行后，输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDeferAnonymousFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;First defer&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Second defer&quot;</span>)<br>    &#125;()<br>    fmt.Println(<span class="hljs-string">&quot;Function body&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、iota"><a href="#二、iota" class="headerlink" title="二、iota"></a>二、iota</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> (<br>            a = <span class="hljs-literal">iota</span>   <span class="hljs-comment">//0</span><br>            b          <span class="hljs-comment">//1</span><br>            c          <span class="hljs-comment">//2</span><br>            d = <span class="hljs-string">&quot;ha&quot;</span>   <span class="hljs-comment">//独立值，iota += 1</span><br>            e          <span class="hljs-comment">//&quot;ha&quot;   iota += 1</span><br>            f = <span class="hljs-number">100</span>    <span class="hljs-comment">//iota +=1</span><br>            g          <span class="hljs-comment">//100  iota +=1</span><br>            h = <span class="hljs-literal">iota</span>   <span class="hljs-comment">//7,恢复计数</span><br>            i          <span class="hljs-comment">//8</span><br>    )<br>    fmt.Println(a,b,c,d,e,f,g,h,i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、interface"><a href="#三、interface" class="headerlink" title="三、interface"></a>三、interface</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p> Go语言接口(interface)</p><p>接口是Go语言中一个非常重要的特性,它定义了一组方法签名。接口提供了一种方式来说明对象的行为：如果某个对象实现了某个接口的所有方法,那么它就实现了这个接口。</p><ul><li>接口类型是对其他类型行为的抽象和概括</li><li>接口类型是一组方法签名的集合</li><li>任何类型的对象实现了接口中的所有方法,它就实现了这个接口</li></ul><h3 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2. 定义接口"></a>2. 定义接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// 接口可以嵌入其他接口</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、slice"><a href="#四、slice" class="headerlink" title="四、slice"></a>四、slice</h2><p>总所周知切片作为一种数据类型，作为值在函数中传递时是值传递，实际上在go语言中所有的类型传递都是值传递，而不是引用传递。</p><h3 id="一、打印结果"><a href="#一、打印结果" class="headerlink" title="一、打印结果"></a>一、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">7</span>)<br><br>x := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">8</span>)<br>y := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">9</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;t:&quot;</span>, s, x, y)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、打印结果"><a href="#二、打印结果" class="headerlink" title="二、打印结果"></a>二、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;AAAA/BBBBB&quot;</span>)<br>    index := bytes.IndexByte(a, <span class="hljs-string">&#x27;/&#x27;</span>)<br>    b := a[:index]<br>    c := a[index+<span class="hljs-number">1</span>:]<br>    b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&quot;CCC&quot;</span>...)<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(a))<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(b))<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(c))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、打印结果"><a href="#三、打印结果" class="headerlink" title="三、打印结果"></a>三、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">s0</span><span class="hljs-params">()</span></span> &#123;<br>    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    x := s[:<span class="hljs-number">1</span>]<br>    y := s[<span class="hljs-number">2</span>:]<br><br>    x = <span class="hljs-built_in">append</span>(x, y...)<br>    x = <span class="hljs-built_in">append</span>(x, y...)<br><br>    fmt.Println(<span class="hljs-string">&quot;s0: s=&quot;</span>, s, <span class="hljs-string">&quot;   x=&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、reflect"><a href="#五、reflect" class="headerlink" title="五、reflect"></a>五、reflect</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>Go语言的反射（Reflection）是指在程序运行时检查、修改变量的类型和值，以及调用它们的方法的能力。<br>Go语言的reflect包提供了一系列强大的功能，允许在运行时检查、修改变量的类型和值，以及调用它们的方法。</p><h3 id="常用的reflect包方法"><a href="#常用的reflect包方法" class="headerlink" title="常用的reflect包方法"></a>常用的reflect包方法</h3><h4 id="获取类型和值"><a href="#获取类型和值" class="headerlink" title="获取类型和值"></a>获取类型和值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">reflect.TypeOf(i <span class="hljs-keyword">interface</span>&#123;&#125;) reflect.Type：获取任何值的类型。<br>reflect.ValueOf(i <span class="hljs-keyword">interface</span>&#123;&#125;) reflect.Value：获取任何值的reflect.Value表示。<br></code></pre></td></tr></table></figure><h4 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v.Kind() reflect.Kind：返回v的类型种类（如Int、Slice等）。<br>v.Type() reflect.Type：返回v的准确类型。<br></code></pre></td></tr></table></figure><h4 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v.Elem() reflect.Value：获取指针或接口类型变量所指向的实际变量。<br>v.SetInt(<span class="hljs-type">int64</span>)、v.SetFloat(<span class="hljs-type">float64</span>)等：如果v是可设置的（v.CanSet() == <span class="hljs-literal">true</span>），则修改其值。<br></code></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v.MethodByName(name <span class="hljs-type">string</span>) reflect.Value：根据方法名获取v的方法。<br>v.Call(in []reflect.Value) []reflect.Value：调用v表示的方法。<br></code></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="什么是-reflect-包？它的主要用途是什么？"><a href="#什么是-reflect-包？它的主要用途是什么？" class="headerlink" title="什么是 reflect 包？它的主要用途是什么？"></a>什么是 reflect 包？它的主要用途是什么？</h4><p>reflect 包用于在运行时动态地检查和操作 Go 程序中的变量类型和数据值。它可以用于实现一些需要在运行时了解类型或结构的功能，例如序列化、调试、动态调用等。</p><h4 id="reflect-Type-和-reflect-Value-有什么区别？"><a href="#reflect-Type-和-reflect-Value-有什么区别？" class="headerlink" title="reflect.Type 和 reflect.Value 有什么区别？"></a>reflect.Type 和 reflect.Value 有什么区别？</h4><p>reflect.Type 用于表示变量的类型信息，而 reflect.Value 用于表示变量的实际值。reflect.Type 提供了类型的描述信息，而 reflect.Value 提供了对实际值的操作方法。</p><h2 id="六、闭包"><a href="#六、闭包" class="headerlink" title="六、闭包"></a>六、闭包</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>什么是闭包？在Go语言中如何实现闭包？<br></p><p>答：闭包是指一个函数和它引用的外部变量构成的实体。在Go语言中，闭包是一个函数值，它可以访问函数体之外声明的变量。在Go语言中实现闭包的方法是，将一个函数和其引用的变量封装在一个结构体中，并返回这个结构体中的函数。</p><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><h5 id="1、下面的代码输出什么？"><a href="#1、下面的代码输出什么？" class="headerlink" title="1、下面的代码输出什么？"></a>1、下面的代码输出什么？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">goCopy code<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := foo()<br>    fmt.Println(f())<br>    fmt.Println(f())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        i++<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2、闭包和函数的区别是什么？"><a href="#2、闭包和函数的区别是什么？" class="headerlink" title="2、闭包和函数的区别是什么？"></a>2、闭包和函数的区别是什么？</h5><p>答：闭包和函数都可以用来封装代码，但闭包可以访问其外部作用域中的变量，而函数只能访问其参数和局部变量。因此，闭包可以用来实现状态的保持，而函数则不能。</p><h5 id="3、下面的代码输出什么？"><a href="#3、下面的代码输出什么？" class="headerlink" title="3、下面的代码输出什么？"></a>3、下面的代码输出什么？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">goCopy code<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>    &#125;<br>    g := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;World&quot;</span>)<br>    &#125;<br>    h := []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    h = <span class="hljs-built_in">append</span>(h, f)<br>    h = <span class="hljs-built_in">append</span>(h, g)<br>    <span class="hljs-keyword">for</span> _, fn := <span class="hljs-keyword">range</span> h &#123;<br>        fn()<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="4、闭包会引起什么问题？如何避免这些问题？"><a href="#4、闭包会引起什么问题？如何避免这些问题？" class="headerlink" title="4、闭包会引起什么问题？如何避免这些问题？"></a>4、闭包会引起什么问题？如何避免这些问题？</h5><p>答：闭包会引起内存泄漏问题，如果一个闭包引用了一个大对象，而该闭包又被长时间持有，那么这个大对象就会被一直占用内存，无法被 GC 回收。为了避免这个问题，可以尽量避免在闭包中引用大对象，或者手动将闭包设置为 nil，以释放其对对象的引用。</p><h2 id="七、Go语言中的错误处理——recover和panic"><a href="#七、Go语言中的错误处理——recover和panic" class="headerlink" title="七、Go语言中的错误处理——recover和panic"></a>七、Go语言中的错误处理——recover和panic</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><strong>panic</strong> 与 <strong>recover</strong> 是 Go 的两个内置函数，这两个内置函数用于处理 Go 运行时的错误，panic 用于主动抛出错误，recover 用来捕获 panic 抛出的错误。<br></p><p>当发生运行时异常时，程序会出现panic，造成严重的线上事故，使用recover可以避免这种严重的线上事务。</p><p><img src="/2024/07/28/%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image.png" alt="图片1"></p><p>panic发生时会依次执行：<br><br>1、逆序执行当前goroutine的defer链（recover从这里介入）<br><br>2、打印错误信息和调用堆栈<br><br>3、调用exit(2)结束整个进程<br></p><p>不使用recover时panic就会直接执行到第三点，退出程序<br><br>使用recover后，panic会直接介入到recover，而不会直接退出程序</p><ul><li>引发panic有两种情况，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。</li><li>发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数。</li><li>panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或抛出panic。defer里面的panic能够被后续执行的defer捕获。</li><li>recover用来捕获panic，阻止panic继续向上传递。recover()和defer一起使用，但是defer只有在后面的函数体内直接被掉用才能捕获panic来终止异常，否则返回nil，异常继续向外传递。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Recovered from&quot;</span>, r)<br>    &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><br>在Gin框架中，默认为每一个handler都添加了一个recover但是 Gin handle方法里面再调用协程，协程里出现panic，服务端还是会崩因为recover只能捕获本协程的panic，又创建了一个新协程它管不了<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般情况下有两种情况用到：</p><ul><li>程序遇到无法执行下去的错误时，抛出错误，主动结束运行。</li><li>在调试程序时，通过 panic 来打印堆栈，方便定位错误。</li></ul><h2 id="八、读写锁"><a href="#八、读写锁" class="headerlink" title="八、读写锁"></a>八、读写锁</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>读写锁（Read-Write Lock）是一种允许多个读操作同时进行，但写操作在进行时会独占资源的同步机制。与互斥锁（Mutex）不同，互斥锁会阻塞所有的读写操作，确保同一时间只有一个操作（读或写）能访问资源，而读写锁允许多个读操作并发进行，从而提高了并发性能。<br></p><h3 id="读写锁的优势"><a href="#读写锁的优势" class="headerlink" title="读写锁的优势"></a>读写锁的优势</h3><p>读写锁的主要优势是提高了并发性能。当系统主要进行读操作而偶尔有写操作时，读写锁能允许多个读操作同时进行，而只有在写操作时才会阻塞所有读操作，从而提高了系统的并发能力。</p><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="当读操作和写操作同时存在时，读写锁如何表现？"><a href="#当读操作和写操作同时存在时，读写锁如何表现？" class="headerlink" title="当读操作和写操作同时存在时，读写锁如何表现？"></a>当读操作和写操作同时存在时，读写锁如何表现？</h4><p>当有写操作请求时，读写锁会阻塞所有读操作和其他写操作。写操作在完成之前，所有读操作和其他写操作都会被阻塞。</p><h4 id="读写锁的性能特征是什么？"><a href="#读写锁的性能特征是什么？" class="headerlink" title="读写锁的性能特征是什么？"></a>读写锁的性能特征是什么？</h4><p>读写锁在读操作远多于写操作的场景下表现良好，因为它允许多个读操作并发执行。然而，在写操作频繁的场景下，读写锁的性能可能不如互斥锁，因为写操作需要等待所有读操作完成，并且可能会导致写操作的饥饿问题。</p><h4 id="如何处理读写锁的饥饿问题？"><a href="#如何处理读写锁的饥饿问题？" class="headerlink" title="如何处理读写锁的饥饿问题？"></a>如何处理读写锁的饥饿问题？</h4><p>饥饿问题指的是某些操作（读或写）可能因为锁的竞争而被长期阻塞。可以通过公平的读写锁实现（例如使用信号量或队列）来减少饥饿问题，确保读操作和写操作都有机会获得锁。</p><h4 id="如何在多核处理器上优化读写锁的性能？"><a href="#如何在多核处理器上优化读写锁的性能？" class="headerlink" title="如何在多核处理器上优化读写锁的性能？"></a>如何在多核处理器上优化读写锁的性能？</h4><p>在多核处理器上，优化读写锁性能的方法包括减少锁的竞争、使用合适的锁粒度、减少锁的持有时间等。例如，可以通过将锁的粒度设置为较小的区域（而不是整个数据结构）来减少锁竞争，从而提高并发性能。</p><h4 id="读写锁的实现方式有哪些？"><a href="#读写锁的实现方式有哪些？" class="headerlink" title="读写锁的实现方式有哪些？"></a>读写锁的实现方式有哪些？</h4><p>读写锁的实现方式有很多，包括基于信号量的实现、基于队列的实现以及基于自旋锁的实现等。不同的实现方式会在性能和复杂性上有所不同，具体选择哪种实现方式取决于应用的需求和环境。</p><h2 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>泛型是一种在定义数据结构或算法时，允许操作任意类型的能力。泛型使得代码更加灵活和可重用，同时避免了重复编写类似逻辑的代码。它允许编写与类型无关的代码，并在编译时进行类型检查。</p><p>Go 1.18 及以后的版本引入了泛型。泛型可以通过定义带有类型参数的函数或结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>    fmt.Println(value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Print(<span class="hljs-number">42</span>)         <span class="hljs-comment">// 打印整数</span><br>    Print(<span class="hljs-string">&quot;Hello&quot;</span>)    <span class="hljs-comment">// 打印字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="如何避免泛型中的类型约束导致的性能问题？"><a href="#如何避免泛型中的类型约束导致的性能问题？" class="headerlink" title="如何避免泛型中的类型约束导致的性能问题？"></a>如何避免泛型中的类型约束导致的性能问题？</h4><p>泛型的性能问题通常来源于类型约束的复杂性和泛型实例化的多样性。使用简单的类型约束可以减少性能开销，并尽量避免在泛型函数中进行大量的类型检查或转换。</p><h4 id="Go-泛型在标准库中的应用有哪些？"><a href="#Go-泛型在标准库中的应用有哪些？" class="headerlink" title="Go 泛型在标准库中的应用有哪些？"></a>Go 泛型在标准库中的应用有哪些？</h4><p>Go 标准库中的泛型应用较少，但从 Go 1.18 起，标准库开始逐步引入泛型。例如，container&#x2F;heap 和 container&#x2F;list 中的部分操作可以利用泛型提高灵活性和类型安全。</p><h4 id="如何在-Go-中使用泛型约束？请给出一个例子。"><a href="#如何在-Go-中使用泛型约束？请给出一个例子。" class="headerlink" title="如何在 Go 中使用泛型约束？请给出一个例子。"></a>如何在 Go 中使用泛型约束？请给出一个例子。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个约束接口</span><br><span class="hljs-keyword">type</span> Adder[T any] <span class="hljs-keyword">interface</span> &#123;<br>    Add(a, b T) T<br>&#125;<br><br><span class="hljs-comment">// 实现一个具体类型的加法操作</span><br><span class="hljs-keyword">type</span> IntAdder <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(IntAdder)</span></span> Add(a, b <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">A</span> <span class="hljs-title">Adder</span>[<span class="hljs-title">T</span>]]<span class="hljs-params">(a A, x, y T)</span></span> T &#123;<br>    <span class="hljs-keyword">return</span> a.Add(x, y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    adder := IntAdder&#123;&#125;<br>    result := Add(adder, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>    fmt.Println(result) <span class="hljs-comment">// 输出 7</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入学习Go语言：数据结构-切片</title>
    <link href="/2024/07/27/learn_go_slice/"/>
    <url>/2024/07/27/learn_go_slice/</url>
    
    <content type="html"><![CDATA[<h1 id="深入学习Go语言的切片"><a href="#深入学习Go语言的切片" class="headerlink" title="深入学习Go语言的切片"></a>深入学习Go语言的切片</h1><p>在go语言的实际开发中，我们使用更多的是切片而不是数组，数组的固定长度注定了只能在一些特殊的场景下才更具优势。</p><p>切片就像go语言内置的“动态数组”，与数组相比切片的长度往往是固定的，可以追加元素，在追加时可以使切片的容量增大。</p><p><strong>今天我们主要学习探讨的是切片函数传值、切片动态扩容、切片对底层数组的引用等问题</strong></p><h2 id="一、什么是切片？"><a href="#一、什么是切片？" class="headerlink" title="一、什么是切片？"></a>一、什么是切片？</h2><ol><li><p>在Go语言中，<strong>切片</strong>（slice）是对数组的一个抽象。切片比数组更灵活、功能更强大，是Go语言中非常常用的数据结构。切片本质上是一个指向数组的引用，因此它是引用类型。</p><br></li><li><p>你可以声明一个未指定大小的数组来定义<strong>切片</strong>：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>切片有两个重要的参数：长度、容量</p><p>使用 make() 函数来创建切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>, capacity)<br><br>也可以简写为<br><br>slice1 := <span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure><h2 id="二、切片的底层原理？"><a href="#二、切片的底层原理？" class="headerlink" title="二、切片的底层原理？"></a>二、切片的底层原理？</h2><h3 id="切片的函数传值"><a href="#切片的函数传值" class="headerlink" title="切片的函数传值"></a>切片的函数传值</h3><p>有一天我水群的时候看到群友遇到了一个问题：</p><p>问：这段代码中，容量为5，长度为0，append一个元素，明显不会触发扩容，为什么结果却没有修改切片呢</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br>ap(slice)<br>fmt.Println(slice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ap</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>总所周知切片作为一种数据类型，作为值在函数中传递时是值传递，实际上在go语言中所有的类型传递都是值传递，而不是引用传递。</p><p>但是就算是值传递，切片副本与原切片指向的底层数组是相同的。在副本中append，底层数组的长度从0变成1，但是原切片的长度是0，因此虽然底层数组改变了但原切片也看不到只能显示[]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br>ap(slice)  <br>fmt.Println(slice) <span class="hljs-comment">// []</span><br>    slice.<span class="hljs-built_in">len</span> = <span class="hljs-number">1</span>      <span class="hljs-comment">// 假如可以更改len属性的话</span><br>    fmt.Println(slice) <span class="hljs-comment">// [1]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ap</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>) <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、切片面试题"><a href="#三、切片面试题" class="headerlink" title="三、切片面试题"></a>三、切片面试题</h2><h3 id="一、打印结果"><a href="#一、打印结果" class="headerlink" title="一、打印结果"></a>一、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">7</span>)<br><br>x := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">8</span>)<br>y := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">9</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;t:&quot;</span>, s, x, y)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、打印结果"><a href="#二、打印结果" class="headerlink" title="二、打印结果"></a>二、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;AAAA/BBBBB&quot;</span>)<br>    index := bytes.IndexByte(a, <span class="hljs-string">&#x27;/&#x27;</span>)<br>    b := a[:index]<br>    c := a[index+<span class="hljs-number">1</span>:]<br>    b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&quot;CCC&quot;</span>...)<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(a))<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(b))<br>    fmt.Println(<span class="hljs-string">&quot;test5:&quot;</span>, <span class="hljs-type">string</span>(c))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、打印结果"><a href="#三、打印结果" class="headerlink" title="三、打印结果"></a>三、打印结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">s0</span><span class="hljs-params">()</span></span> &#123;<br>    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    x := s[:<span class="hljs-number">1</span>]<br>    y := s[<span class="hljs-number">2</span>:]<br><br>    x = <span class="hljs-built_in">append</span>(x, y...)<br>    x = <span class="hljs-built_in">append</span>(x, y...)<br><br>    fmt.Println(<span class="hljs-string">&quot;s0: s=&quot;</span>, s, <span class="hljs-string">&quot;   x=&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署go-bot</title>
    <link href="/2023/08/11/%E9%83%A8%E7%BD%B2go-bot/"/>
    <url>/2023/08/11/%E9%83%A8%E7%BD%B2go-bot/</url>
    
    <content type="html"><![CDATA[<p>1.Golang版本，选1.20<br>2.稳定版本签名服务器以及gocq地址：<a href="https://gitee.com/changwenpeng/gocqhttp-qqsign">https://gitee.com/changwenpeng/gocqhttp-qqsign</a><br>3.ZeroBot-Plugin地址：<a href="https://github.com/FloatTech/ZeroBot-Plugin">https://github.com/FloatTech/ZeroBot-Plugin</a><br>4.b站部署视频：【搭建一个QQ功能型机器人,零基础教学-ZeroBot-Plugin搭建教程(第一课)】<a href="https://www.bilibili.com/video/BV1mg411t71u?vd_source=1a1c746d22cfe6fcfe918074ac82defa">https://www.bilibili.com/video/BV1mg411t71u?vd_source=1a1c746d22cfe6fcfe918074ac82defa</a><br>（主要讲gocq和ZeroBot-Plugin通讯）<br>5.gocphttp地址：<a href="https://github.com/Mrs4s/go-cqhttp">https://github.com/Mrs4s/go-cqhttp</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>城市交通安全系统数据库设计</title>
    <link href="/2023/05/11/%E5%9F%8E%E5%B8%82%E4%BA%A4%E9%80%9A%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/11/%E5%9F%8E%E5%B8%82%E4%BA%A4%E9%80%9A%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>![思维导图]（image.jpg）</p>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入学习sqlsever数据库</title>
    <link href="/2023/04/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0sqlsever%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/04/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0sqlsever%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="深入学习sqlsever数据库"><a href="#深入学习sqlsever数据库" class="headerlink" title="深入学习sqlsever数据库"></a>深入学习sqlsever数据库</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为学习笔记，可能有很多错误 <br><br>欢迎指正</p><h2 id="学习数据库必须要搞懂的问题"><a href="#学习数据库必须要搞懂的问题" class="headerlink" title="学习数据库必须要搞懂的问题"></a>学习数据库必须要搞懂的问题</h2><p>1.学习数据库管理平台安装和使用<br>主要内容：能够安装数据库管理平台并且正常的使用<br>考核内容：了解sa用户与其他身份用户的区别，用户配置，远程访问配置<br>考核标准：数据库能正常使用并且能够远程访问（可在局域网中验证）</p><p>2.保存使用过的sql语句<br>主要内容：对于验证执行过的SQL语句进行一个整理与保存<br>考核内容：每一个知识点都需要有相应的SQL语句<br>考核标准：能够将养成整理归纳验证使用过的SQL语句</p><p>3.建立数据库<br>主要内容：熟悉create database语句以及图形化建库的使用<br>考核内容：熟练使用create database与图形化界面进行建库操作，包含对数据库编码方式的了解<br>考核标准：建立一个教务管理系统数据库</p><p>4.一对多、多对多的关系<br>主要内容：了解并且理解实体关系中的一对多、多对多关系<br>考核内容：给出一个实际需求能够抽象出其实体之间的关系<br>考核标准：能够抽象出简单教务管理系统的实体关系</p><p>5.建表<br>主要内容：通过SQL语句以及图形化界面来新建表<br>考核内容：表的命名规范、字段的数据类型限制以及字段的命名规范<br>考核标准：能够根据实际业务需求来创建一个简单的教务管理系统数据库表</p><p>6.约束的作用<br>主要内容：查资料了解什么是约束，约束的作用<br>考核内容：讲解自己的理解<br>考核标准：能够正确表达约束的作用</p><p>7.主键外键的约束<br>主要内容：主外键约束的SQL语句和图形界面操作<br>考核内容：建立起主外键<br>考核标准：能够建立起约束关系</p><p>8.根据实际业务需求向数据库填充模拟数据<br>主要内容：<br>考核内容：<br>考核标准：</p><p>9.备份还原，导入导出<br>主要内容：在图形界面上进行数据库的备份还原，导入导出<br>考核内容：数据库的备份还原，导入导出<br>考核标准：成功进行备份还原，导入导出<br><a href="https://www.cnblogs.com/wangwangwangMax/p/5417662.html">https://www.cnblogs.com/wangwangwangMax/p/5417662.html</a></p><p>10.结构化查询语句的书写<br>主要内容：SQL语句的书写与使用（保存使用过的SQL语句）<br>考核内容：查看个人的SQL语句保存情况<br>考核标准：SQL语句是否完整</p><p>11.储存过程和触发器<br>主要内容：学习储存过程和触发器的书写与使用，<br>考核内容：储存过程和触发器的格式与使用<br>考核标准：能够正确的运行并得到正确的输出<br>储存过程：<a href="https://www.cnblogs.com/sayhallotoyou/p/4282770.html">https://www.cnblogs.com/sayhallotoyou/p/4282770.html</a><br>和<a href="https://www.w3cschool.cn/sqlserver/sqlserver-hw2328n6.html">https://www.w3cschool.cn/sqlserver/sqlserver-hw2328n6.html</a></p><p>12.视图、关联查询<br>主要内容：通过SQL语句以及图形化界面来创建视图和建立关联<br>考核内容：创建视图和关联查询的SQL语句，创建视图和关联查询的图形界面流程<br>考核标准：SQL语句能正确的执行，图形化界面操作无误</p><p>13.其他内容<br>a.数据库设计范式的了解<br>b.各类数据库的区别及优缺点<br>c.现阶段数据库的发展的了解</p><h2 id="什么是一对多、多对多"><a href="#什么是一对多、多对多" class="headerlink" title="什么是一对多、多对多"></a>什么是一对多、多对多</h2><p>多对多（Many-to-Many，简称M：N）关系是关系型数据库中常见的一种关系类型。它表示两个实体（entity）之间存在多对多的关系。举个例子，一个学生可以选修多个课程，一个课程也可以被多个学生选修，这就是一个经典的多对多关系。<br>深入理解多对多关系需要理解以下几个概念：</p><ol><li>实体：在多对多关系中，实体通常是指两个或多个具有相同属性的对象，例如学生和课程。</li><li>关联表：为了表示多对多关系，通常需要创建一个关联表，也称为中间表（Intermediate Table）或交叉引用表（Cross-Reference Table），用于存储两个实体之间的关系。关联表通常包含两个或多个外键（外键）</li><li>主键和外键：主键是表中用于唯一标识每个记录的字段，通常是一个自增长的整数。外键是一个指向其他表中主键的字段，用于建立表与表之间的关联关系。<br>在理解了这些概念之后，我们可以进一步了解多对多关系的工作原理。例如，在上述学生和课程的例子中，我们可以创建一个名为“选课表”（Course_Student）的关联表，该表包含两个外键，分别指向学生表和课程表。当一个学生选修一个课程时，在选课表中插入一条记录，将学生的ID和课程的ID作为外键值。通过这种方式，我们可以轻松地查询出一个学生所选的所有课程，或者查询一个课程所有被哪些学生选修。<br>需要注意的是，在多对多关系中，关联表的设计和建立是非常重要的，需要遵循数据库规范化的原则，以确保数据的完整性和一致性。同时，在进行多对多关系的查询和操作时，需要熟练掌握SQL语言的JOIN操作和子查询等高级技巧。</li></ol><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>在SQL中，ROLLBACK TRAN是用于撤销当前事务（Transaction）中的所有操作并回滚到事务开始前的状态。事务是指一系列数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部失败回滚。ROLLBACK TRAN的作用是在事务执行过程中发生了错误或者意外情况时，撤销所有已执行的操作，确保数据库的完整性和一致性。<br>以下是一个简单的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlCopy code<br><span class="hljs-keyword">BEGIN</span> TRAN;<br><span class="hljs-keyword">UPDATE</span> table1 <span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;value1&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table2 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">ROLLBACK</span> TRAN;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先使用BEGIN TRAN开启一个事务，并执行了一个UPDATE和一个DELETE操作。如果在这个过程中出现了错误，可以使用ROLLBACK TRAN来撤销这两个操作，恢复到事务开始前的状态，从而避免了对数据库的损坏。<br>需要注意的是，ROLLBACK TRAN只能用于回滚当前事务中的操作，而不能回滚其他事务的操作。此外，当多个事务同时操作同一数据库时，需要通过锁机制来确保数据的一致性。</p><p><strong>有些触发器的使用为了避免触发器和主键的冲突，需要去掉主键，那这个触发器有什么意义?</strong><br></p><p>即使去掉主键约束，触发器仍然可以用于实现其他数据完整性约束或自动化业务逻辑。主键约束只是数据表中一种约束性条件，用于确保表中的行具有唯一性标识符。但在某些情况下，可能需要去掉主键约束，例如，需要允许表中存在重复的行，或者数据模型设计上不需要主键，而使用其他方式保证数据的唯一性。在这种情况下，可以使用触发器来实现其他数据完整性约束或自动化业务逻辑的需求。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="存储过程里面的-out-有什么作用"><a href="#存储过程里面的-out-有什么作用" class="headerlink" title="存储过程里面的 out 有什么作用"></a>存储过程里面的 out 有什么作用</h3><p>在存储过程中，OUT参数可以用于返回一个或多个输出值。当存储过程执行完成后，OUT参数的值将被赋给执行存储过程的程序或语句，可以使用这些输出值来做进一步的处理。<br>在上述存储过程中，有5个OUT参数，分别用来返回查询结果的不同字段值，例如@StudentNum用于返回学生的学号，@StudentName用于返回学生的姓名，以此类推。当存储过程执行完成后，这些OUT参数将被赋上相应的值，并可以在调用存储过程的程序或语句中使用这些输出值。</p><h3 id="out-和putout-有什么区别吗"><a href="#out-和putout-有什么区别吗" class="headerlink" title="out 和putout 有什么区别吗"></a>out 和putout 有什么区别吗</h3><p>在存储过程中，OUT和OUTPUT都是用于声明输出参数的关键字，它们的主要作用都是将存储过程的执行结果传递给调用程序。不过，它们的使用方式略有不同：<br>● OUT：用于声明一个输出参数，可以将存储过程的执行结果赋值给该参数。在调用存储过程之前，需要声明该参数，并将其作为参数传递给存储过程。在存储过程中，可以通过给该参数赋值来传递执行结果。<br>● OUTPUT：也用于声明一个输出参数，但它可以将参数的值返回给调用程序。与OUT不同的是，调用程序需要将声明的参数传递给存储过程，并在调用完成后从该参数中获取返回值。<br>因此，OUT和OUTPUT的主要区别在于它们的返回值方式不同：OUT是通过赋值来传递执行结果，而OUTPUT是通过返回值来传递执行结果。</p><h3 id="在存储过程中，CAST-是一种数据类型转换函数，用于将一个数据类型转换为另一个数据类型。它的语法为："><a href="#在存储过程中，CAST-是一种数据类型转换函数，用于将一个数据类型转换为另一个数据类型。它的语法为：" class="headerlink" title="在存储过程中，CAST 是一种数据类型转换函数，用于将一个数据类型转换为另一个数据类型。它的语法为："></a>在存储过程中，CAST 是一种数据类型转换函数，用于将一个数据类型转换为另一个数据类型。它的语法为：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlCopy code<br><span class="hljs-built_in">CAST</span>(expression <span class="hljs-keyword">AS</span> data_type)<br></code></pre></td></tr></table></figure><p>其中，expression 是要进行数据类型转换的表达式或列名，data_type 是目标数据类型。<br>例如，下面的存储过程使用 CAST 将 @SalesAmount 变量的数据类型从 decimal 转换为 int：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlCopy code<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> dbo.GetOrdersBySalesAmount<br>    <span class="hljs-variable">@SalesAmount</span> <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    <span class="hljs-variable">@ResultsCount</span> <span class="hljs-type">int</span> <span class="hljs-keyword">OUT</span><br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@ResultsCount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-keyword">FROM</span> Sales.Orders<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">CAST</span>(OrderTotal <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>) <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(<span class="hljs-variable">@SalesAmount</span> <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>在上面的存储过程中，CAST(@SalesAmount AS int) 会将 @SalesAmount 的数据类型从 decimal 转换为 int，以便将其与 OrderTotal 列进行比较。</p><h2 id="对数据的理解"><a href="#对数据的理解" class="headerlink" title="对数据的理解"></a>对数据的理解</h2><p>数据库是在应用软件级别研究数据的存储和操作<br>数据结构是在系统软件级别研究数据的存储和操作</p><p>什么是连接？</p><p>上面的按钮都是客户端<br>不是数据库<br>只是一个可以访问后台数据库的软件<br>库和访问库的软件是可以分开的</p><p>sql语言是命令性的语言</p><p>有了编程语言为什么还需要数据库<br>对内存数据操作时编程语言的强项，但是对硬盘数据操作却是编程语言的的弱项<br>对硬盘数据操作确实数据库的强项，是数据库研究的核心问题</p><p>建议初学者从三个方面学习数据库<br>1.数据库是如何存储数据的<br>      字段、记录、表、约束（主键 外键 唯一键 非空 check default）<br>2.数据库是如何操作数据的<br>       insert update delete T-SQL  存储过程  函数  触发器<br>3.数据库是如何显示数据的<br>        select（重点的重点）</p><p>BEGIN…END语句用于定义语句块，语句块由一组一起执行的SQL语句组成。 语句块也称为批处理。<br>换句话说，如果语句是句子，则BEGIN…END语句允许定义段落。</p><p>GO是批处理的标志，是一条或多条SQL语句的集合，SQL Server将批处理语句编译成一个可执行单元，此单元称为执行计划。</p><p>数据库设计范式是指用于规范化(relational normalization)数据库模式设计的一系列规则。规范化是指通过分解关系模式，将数据存储在多个表中以减少冗余数据并确保数据的一致性和完整性。范式的目标是在数据的存储过程中最小化数据冗余，并消除潜在的数据不一致性和不完整性问题。<br>以下是常见的数据库设计范式：</p><ol><li>第一范式（1NF）：确保每个属性都是原子的，不可再分解的。也就是每个属性只包含单个的值，而不是一组值。</li><li>第二范式（2NF）：确保每个非主键属性都完全依赖于主键而不是部分依赖。也就是每个非主键属性都与主键直接相关，而不是与主键的某一部分相关。</li><li>第三范式（3NF）：确保每个非主键属性都不依赖于其他非主键属性，也就是每个非主键属性都只与主键相关，而不是与其他非主键属性相关。<br>在实践中，通常只需要满足前两个范式（1NF和2NF）就足够了。但是，对于一些大型、复杂的数据库，使用更高级的范式可以确保数据更加规范和一致，减少数据冗余和不一致性的问题。</li></ol><p>是的，这些范式是按照一定的顺序来应用的，并且每个范式都是建立在前一个范式的基础上。因此，每个范式都依赖于前一个范式的规则，并扩展其概念。<br>具体来说，第一范式（1NF）是规范化的第一个阶段，它要求数据库表中的每个列都具有原子性。第二范式（2NF）是在1NF的基础上建立的，它要求每个非主键列完全依赖于主键，而不是仅依赖于部分主键。第三范式（3NF）是在2NF的基础上建立的，它要求每个非主键列不依赖于其他非主键列。<br>除此之外，还有其他的范式，如巴斯-科德范式（BCNF），第四范式（4NF），第五范式（5NF）等，它们在3NF的基础上进一步规范化数据库设计，更加强调数据的完整性和关联性。但是，在实践中，并不总是需要满足所有的范式。设计人员需要根据具体情况来选择最适合应用的规范化范式。</p><p>数据库技术一直在不断地发展和进步。现在，随着云计算和大数据技术的兴起，数据库技术也在迎来一个新的发展阶段。以下是当前数据库发展的一些趋势和方向：</p><ol><li>云数据库：云数据库是指将数据库服务部署在云平台上，用户可以通过互联网访问和管理数据库，无需自己搭建和维护数据库系统。云数据库具有高可用性、可伸缩性和安全性等优点，越来越受到企业和用户的青睐。</li><li>NoSQL数据库：NoSQL数据库是指非关系型数据库，其不使用传统的表格模型，而是采用其他数据结构，如文档、键值对、图形等，以实现更高效的数据存储和查询。NoSQL数据库适合大数据存储和分析场景，能够快速地处理海量数据。</li><li>新SQL数据库：新SQL数据库是指既有传统关系型数据库的特点，又兼具分布式、高可用性和可伸缩性等特点。新SQL数据库的出现，旨在弥补传统关系型数据库在大数据环境下的不足，提供更好的性能和可扩展性。</li><li>数据安全和隐私保护：随着数据泄漏和安全漏洞的不断发生，数据安全和隐私保护越来越受到关注。数据库开发者需要采取一系列措施，如加密、访问控制、数据脱敏等，来确保数据的安全性和隐私性。</li><li>人工智能和机器学习：人工智能和机器学习技术的发展，为数据库技术带来了新的挑战和机遇。数据库开发者需要利用人工智能和机器学习技术，提高数据库的自主性、智能化和自我优化能力。<br>总的来说，数据库技术在不断地发展和演进，以适应新的业务场景和技术趋势。数据库开发者需要不断学习和更新技术，以应对不断变化的需求和挑战。</li></ol><p>目前市场上存在着多种类型的数据库，每种数据库都有自己的优点和缺点。选择哪一款数据库进行学习，应该根据实际需求和用途来选择。以下是几种常见的数据库类型和其特点：</p><ol><li>关系型数据库：关系型数据库是一种使用关系模型来组织和存储数据的数据库。它的最大特点是数据之间的关系，使用SQL语言进行数据管理。常见的关系型数据库有Oracle、MySQL、SQL Server等。优点是成熟稳定、标准化程度高、适合处理结构化数据，缺点是扩展性不强、处理大量数据时性能较低。</li><li>非关系型数据库（NoSQL）：非关系型数据库是指使用非关系型数据模型来组织和存储数据的数据库。与关系型数据库不同，它不使用SQL语言进行数据管理，而是采用其他数据查询语言或API。NoSQL数据库的种类很多，常见的有MongoDB、Cassandra、Redis等。优点是适合处理非结构化或半结构化数据，支持高并发和分布式架构，缺点是数据一致性难以保证，难以进行复杂的查询和统计。</li><li>内存数据库：内存数据库是将数据存储在内存中的数据库，其读写速度非常快，常用于需要高速处理的场景，如高速缓存、实时数据分析等。常见的内存数据库有Redis、Memcached等。优点是速度快、支持高并发、易于扩展，缺点是数据持久化困难、容易丢失数据。</li><li>图数据库：图数据库是一种使用图模型来组织和存储数据的数据库，适合处理复杂的数据关系和图形数据。常见的图数据库有Neo4j、FlockDB等。优点是处理关系数据方便、容易进行图形分析，缺点是不适合处理结构化数据。<br>综上所述，选择哪一款数据库进行学习，应该根据实际需求和用途来选择。如果需要处理结构化数据，可以选择关系型数据库；如果需要处理非结构化数据或需要高并发和分布式架构，可以选择NoSQL数据库；如果需要高速处理或实时数据分析，可以选择内存数据库；如果需要处理复杂的数据关系或图形数据，可以选择图数据库。当然，作为初学者，建议从关系型数据库开始学习，因为它具有广泛的应用和较为完善的生态系统，易于入门和掌握。</li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p> 对一个表中的属性操作的限制叫做约束<br>单引号是标志字符串，双引号是用于起名<br>分类<br>主键约束<br>不允许重复元素 避免了数据的冗余<br>外键约束<br>通过外键约束从语法上保证了本事物所关联的其他事物是一定存在的<br>事物和事物之间的关系是通过外键实现的<br>check约束<br>对值进行一定的限定<br>意义：保证事物属性的取值在合法的范围之内<br>default约束<br>默认的值<br>意义：保证事物的属性一定有一个值<br>unique约束<br>主键和唯一键的区别是：<br>主键不允许为空<br>唯一键允许为空  </p><p>在关系型数据库中，主键和外键是非常重要的概念，它们的作用如下：</p><ol><li>主键的作用：<br>主键是用于唯一标识一张表中每一行数据的一列或一组列，它的作用主要有以下几个方面：<br>● 确保数据的唯一性：主键要求每一条记录都有一个唯一的标识符，这可以防止数据重复或冲突。<br>● 提高数据查询的效率：主键可以作为索引（Index）来优化查询，加快数据检索的速度。<br>● 约束数据的完整性：主键可以作为数据完整性约束的一部分，保证数据的一致性和准确性。</li><li>外键的作用：<br>外键是用于建立表与表之间的关联关系的，它的作用主要有以下几个方面：<br>● 建立表与表之间的关联关系：外键可以将两个或多个表之间的数据联系起来，使得它们能够进行关联查询和数据交互。<br>● 保持数据的一致性：外键可以限制在一个表中的数据只能与另一个表中的数据进行关联，避免出现无意义的数据关联。<br>● 约束数据的完整性：外键可以作为数据完整性约束的一部分，保证数据的一致性和准确性。<br>总之，主键和外键是关系型数据库设计的基本原则之一。它们能够保证数据的一致性、准确性和完整性，提高数据操作的效率和可靠性。</li></ol><h2 id="SQL-SELECT-DISTINCT语句"><a href="#SQL-SELECT-DISTINCT语句" class="headerlink" title="SQL SELECT DISTINCT语句"></a>SQL SELECT DISTINCT语句</h2><p>在表中，可能包含重复值<br>有时仅仅希望列出不同（distinct）值</p><p>SELECT Company FROM Orders<br>可返回唯一不同的值</p><p>where子句<br>SEKECT  列名称  FROM 表名称 where<br>列  运算符  值</p><p>引号的使用<br>请注意，我们在例子中的条件值周围使用的是单引号。<br>SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</p><p>ORDER BY 语句<br>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>ORDER BY 语句默认按照升序对记录进行排序。<br>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><h2 id="最后给一个练习"><a href="#最后给一个练习" class="headerlink" title="最后给一个练习"></a>最后给一个练习</h2><p>悉尼美术馆是位于澳大利亚悉尼的大型美术馆。博物馆收集各种艺术品，包括水彩画，油画，粉彩，版画，木炭和其他绘画，雕塑和陶瓷， I拼贴画和摄影作品。博物馆策划的作品范围从现代到文艺复兴时<br></p><p>博物馆管理的艺术品已安全存储或摆放。艺术品可以在博物馆展出，也可以在澳大利亚各地的艺术品展览中展出。艺术品也被借给美术馆，美术馆然后向博物馆支付酬金。<br></p><p>需要一个数据库来存储有关博物馆管理的艺术品的信息，包括艺术品的标题，类型和大小(出于规划展示的目的)，艺术品的当前位置(如果在博物馆展出)，信息等。有关艺术家的信息以及他&#x2F;她创作艺术品的时间，以及艺术品当前是借给美术馆还是在艺术品展览中展示。<br></p><p>支付给博物馆的酬金通常是根据借来的物品在另一个画廊的时间长短来确定的，因此悉尼美术馆的馆长希望跟踪这些信息。策展人还想知道何时在特定的艺术展览中展示作品。<br></p><p>您的任务是设计和开发一个数据库，以支持美术馆的信息系统需求。您不需要开发将使用该数据库的应用程序，但是您将需要构建一些查询</p>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打包python的方法</title>
    <link href="/2022/07/13/%E6%89%93%E5%8C%85python%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/13/%E6%89%93%E5%8C%85python%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="本文主要记录pyinstaller的打包方式"><a href="#本文主要记录pyinstaller的打包方式" class="headerlink" title="本文主要记录pyinstaller的打包方式"></a>本文主要记录pyinstaller的打包方式</h2><h3 id="安装pyinstaller"><a href="#安装pyinstaller" class="headerlink" title="安装pyinstaller"></a>安装pyinstaller</h3><p>命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pip install pyinstaller<br></code></pre></td></tr></table></figure><h4 id="使用pyinstaller进行打包"><a href="#使用pyinstaller进行打包" class="headerlink" title="使用pyinstaller进行打包"></a>使用pyinstaller进行打包</h4><p>pyinstaller 最重要的两个参数就是 -F 与 -D 参数。</p><p>使用 - F 参数， pyinstaller 会将 python 程序打包成单个可执行文件。</p><p>使用 - D 参数， pyinstaller 会将 python 程序打包成一个文件夹，运行程序时，需要进入该文件夹，点击运行相应的可执行程序。</p><p>为了美观，还可以通过 - i 参数指定打包程序的图标 (icon)，但这个命令只能在 Windows 平台下生效，此外还可以使用 - n 参数指定生成打包文件的名称。</p><p>如果你使用了 PyQt5 或 tkinter 开发了界面，通常不会希望程序运行时弹出 cmd 命令行，此时就可以使用 - w 参数。</p><p>简单总结一下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-F：打包 Python 程序为单个可执行文件</span><br><br><span class="hljs-deletion">-D：打包 Python 程序为一个文件夹</span><br><br><span class="hljs-deletion">-i：生成图标，只适用于 Windows 平台</span><br><br><span class="hljs-deletion">-n：指定打包后生成文件的名称</span><br><br><span class="hljs-deletion">-w：禁止命令行弹出</span><br></code></pre></td></tr></table></figure><p>使用命令打包文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pyinstaller -F <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><h4 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h4><p>用命令行cd到python程序的更目录打包</p><p>在dist文件下查找exe文件</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决vue 使用 lang=&quot;scss&quot; 报错问题</title>
    <link href="/2022/07/11/hello/"/>
    <url>/2022/07/11/hello/</url>
    
    <content type="html"><![CDATA[<h2 id="错误现象"><a href="#错误现象" class="headerlink" title="错误现象 :"></a>错误现象 :</h2><p>主要是node-sass版本问题，他的版本看和node版本对应</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> ERR! code ELIFECYCLE<br><span class="hljs-attribute">npm</span> ERR! errno <span class="hljs-number">1</span><br><span class="hljs-attribute">npm</span> ERR! node-sass@<span class="hljs-number">4</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span> postinstall: node scripts/build.js<br><span class="hljs-attribute">npm</span> ERR! Exit status <span class="hljs-number">1</span><br><span class="hljs-attribute">npm</span> ERR!<br><span class="hljs-attribute">npm</span> ERR! Failed at the node-sass@<span class="hljs-number">4</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span> postinstall script.<br><span class="hljs-attribute">npm</span> ERR! This is probably not a problem with npm. There is likely additional logging output above.<br><span class="hljs-attribute">npm</span> ERR! A complete log of this run can be found in:<br><span class="hljs-attribute">npm</span> ERR! C:\Users\cpucode\AppData\Roaming\npm-cache_logs\<span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">10</span>T13_48_01_433Z-debug.log<br></code></pre></td></tr></table></figure><p><img src="/2022/07/11/hello/20210610220830132.png" alt="img"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案 :"></a>解决方案 :</h2><p>使用对应的版本</p><p><a href="https://hub.fastgit.org/sass/node-sass">https://hub.fastgit.org/sass/node-sass</a></p><p>都可以看到node和node-sass对应的版本信息</p><p><img src="/2022/07/11/hello/20210610220101374.png" alt="在这里插入图片描述"></p><p>查看版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/11/hello/2021061022021281.png" alt="在这里插入图片描述"></p><p>与 4.14 对应</p><h2 id="卸载残留问题"><a href="#卸载残留问题" class="headerlink" title="卸载残留问题"></a>卸载残留问题</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">先清依赖残留，否则安装不上<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm rebuild <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm uninstall <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span><br></code></pre></td></tr></table></figure><p>安装 4.14的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install  <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span>@<span class="hljs-number">4.14</span><br></code></pre></td></tr></table></figure><h2 id="解决npm-install报错"><a href="#解决npm-install报错" class="headerlink" title="解决npm install报错"></a>解决npm install报错</h2><p><a href="mailto:&#x6e;&#111;&#100;&#101;&#x2d;&#x73;&#x61;&#115;&#115;&#x40;&#x34;&#46;&#49;&#52;&#x2e;&#x31;">&#x6e;&#111;&#100;&#101;&#x2d;&#x73;&#x61;&#115;&#115;&#x40;&#x34;&#46;&#49;&#52;&#x2e;&#x31;</a> postinstall: <code>node scripts/build.js</code>的问题</p><p>npm install 时报错如下图</p><p><img src="/2022/07/11/hello/20201021154850826.png" alt="报错"></p><p>一开始看Error信息：<br>Error: Can’t find Python executable “python”, you can set the PYTHON env variable.<br>没有python，太奇怪了，然后找了各种方法也没有解决</p><p>后来看可能还是因为node-sass报错：<br><a href="mailto:&#x6e;&#x6f;&#100;&#x65;&#x2d;&#x73;&#97;&#x73;&#115;&#64;&#52;&#46;&#49;&#52;&#46;&#49;">&#x6e;&#x6f;&#100;&#x65;&#x2d;&#x73;&#97;&#x73;&#115;&#64;&#52;&#46;&#49;&#52;&#46;&#49;</a> postinstall: node scripts&#x2F;build.js</p><h4 id="然后找到一个办法："><a href="#然后找到一个办法：" class="headerlink" title="然后找到一个办法："></a>然后找到一个办法：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">sass_binary_site</span>=https://npm.taobao.org/mirrors/node-sass<br></code></pre></td></tr></table></figure><h4 id="然后重新install"><a href="#然后重新install" class="headerlink" title="然后重新install"></a>然后重新install</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install  <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span>@<span class="hljs-number">4.14</span><br></code></pre></td></tr></table></figure><h2 id="启动项目："><a href="#启动项目：" class="headerlink" title="启动项目："></a>启动项目：</h2><p>安装其他依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>启动项目：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> dev<br></code></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://blog.csdn.net/zhao97/article/details/109203025">(2条消息) npm install报错node-sass@4.14.1 postinstall: <code>node scripts/build.js</code>_～倩的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44226094/article/details/117792206">(2条消息) npm install node-sass 报错问题的解决方案_cpuCode的博客-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实参和形参有什么区别</title>
    <link href="/2022/06/29/%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/06/29/%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>实参（actual argument）和形参（formal parameter）是在函数调用中使用的术语，它们有以下区别：</p><ol><li>形参：形参是在函数定义时声明的参数，用于表示函数可以接收的输入值的占位符。形参是函数定义的一部分，用于描述函数的接口和参数类型。它们通常位于函数的括号内，并指定参数的名称和类型。形参在函数定义时并不具有具体的值。</li><li>实参：实参是在函数调用时提供的具体值或表达式，用于传递给函数的参数。实参是根据函数定义的形参列表提供的具体值或变量。在函数调用时，实参的值将被传递给对应的形参，以便函数内部可以使用这些值进行计算和处理。</li></ol><p>简而言之，形参是函数定义时的参数声明，用于描述函数的接口和参数类型；而实参是在函数调用时提供的具体值，用于传递给函数的参数。<br>下面是一个示例，说明形参和实参的区别：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">goCopy <span class="hljs-selector-tag">code</span><br>func add(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> int) int &#123;  // <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> 是形参<br>    return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    result := <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)  // <span class="hljs-number">10</span>, <span class="hljs-number">20</span> 是实参<br>    fmt.<span class="hljs-built_in">Println</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<strong>add</strong> 函数定义了两个形参 <strong>a</strong> 和 <strong>b</strong>，用于表示两个整数相加。在 <strong>main</strong> 函数中，调用 <strong>add</strong> 函数时提供了实参 <strong>10</strong> 和 <strong>20</strong>，它们将被传递给 <strong>add</strong> 函数的形参 <strong>a</strong> 和 <strong>b</strong>，并计算结果返回。</p>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo博文图片不显示的方法</title>
    <link href="/2022/06/17/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E6%96%87%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/17/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E6%96%87%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">配置参考：<br><span class="hljs-symbol">hexo:</span> <span class="hljs-number">6.3</span><span class="hljs-number">.0</span><br>hexo-<span class="hljs-keyword">cli</span>: <span class="hljs-number">4.3</span><span class="hljs-number">.1</span><br><span class="hljs-symbol">node:</span> <span class="hljs-number">14.17</span><span class="hljs-number">.6</span><br></code></pre></td></tr></table></figure><h3 id="先说一下Hexo在博客中插入图片的教程"><a href="#先说一下Hexo在博客中插入图片的教程" class="headerlink" title="先说一下Hexo在博客中插入图片的教程"></a>先说一下Hexo在博客中插入图片的教程</h3><h5 id="【第一步】确保-博客根目录的-config-yml-中-post-asset-folder-true"><a href="#【第一步】确保-博客根目录的-config-yml-中-post-asset-folder-true" class="headerlink" title="【第一步】确保 博客根目录的_config.yml 中 post_asset_folder: true"></a>【第一步】确保 博客根目录的<code>_config.yml</code> 中 <code>post_asset_folder: true</code></h5><p>这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。</p><p><img src="/2022/06/17/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E6%96%87%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/show1.jpg" alt="图片1"></p><h5 id="【第二步】在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"><a href="#【第二步】在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。" class="headerlink" title="【第二步】在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"></a>【第二步】在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><h5 id="【第三步】图片描述"><a href="#【第三步】图片描述" class="headerlink" title="【第三步】图片描述"></a>【第三步】图片描述</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[图片描述]</span>（包名/NO.<span class="hljs-number">01.001</span><span class="hljs-selector-class">.jpg</span>）<br>示例：!<span class="hljs-selector-attr">[]</span>(解决hexo博文图片不显示的方法/show1<span class="hljs-selector-class">.jpg</span>)<br></code></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/2022/06/17/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E6%96%87%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/show2.jpg" alt="图片2"></p><p>添加成功</p><h3 id="图片不显示的解决办法"><a href="#图片不显示的解决办法" class="headerlink" title="图片不显示的解决办法"></a>图片不显示的解决办法</h3><p>也是我遇到的</p><p><a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>-asset-image的版本一定要下载我上面给出的版本，我因为版本不对，困惑了3天才得到解决</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">我之前下的版本是：<br>npm install hexo-asset-<span class="hljs-selector-tag">image</span> <span class="hljs-attr">--save</span>（不好用）<br></code></pre></td></tr></table></figure><h3 id="2024年7月41日更新"><a href="#2024年7月41日更新" class="headerlink" title="2024年7月41日更新"></a>2024年7月41日更新</h3><p>因为电脑重装过一次系统，重新部署博客<br><br>本次使用之前的方法一直不能显示图片</p><p>终于在网上找到了解决办法<br>首先引用资料：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Hexo官方文档：https:<span class="hljs-regexp">//</span>hexo.io<span class="hljs-regexp">/zh-cn/</span>docs/asset-folders<br>CSDN：https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/m0_43401436/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">107191688</span><br></code></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="创建图片资源文件夹"><a href="#创建图片资源文件夹" class="headerlink" title="创建图片资源文件夹"></a>创建图片资源文件夹</h5><p>网上有关的解决方式几乎很大一部分会提到这一点：将_config.yml 文件中的post_asset_folder 选项设为 true 来打开。事实上这正是hexo官方文档给出的解决方案之一中的一个步骤。仔细阅读后会发现如下几点：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>、该操作的作用就是在使用hexo <span class="hljs-keyword">new</span> xxx指令新建博文时，在相同路径下同步创建一个xxx文件夹，而xxx文件夹的作用就是用来存放图片资源；<span class="hljs-symbol">&lt;br&gt;</span><br><span class="hljs-number">2</span>、就我个人而言，我偏好于直接在<span class="hljs-keyword">source</span>\_posts文件夹下新建md文件，而不是通过hexo <span class="hljs-keyword">new</span> xxx指令；<span class="hljs-symbol">&lt;br&gt;</span><br><span class="hljs-number">3</span>、那么直接新建xxx.md再新建xxx文件夹，这种操作的最终效果和使用hexo <span class="hljs-keyword">new</span> xxx指令新建博文的效果一样吗？经过实测，是一样的。<span class="hljs-symbol">&lt;br&gt;</span><br></code></pre></td></tr></table></figure><p>基于以上3点，告诉大家几个结论：<br><br>1、新建博文可以不用hexo new xxx指令，我较为推荐直接新建文件和文件夹的方式，只要达到一个md文件，一个同名文件夹的效果即可；<br>2、【将_config.yml 文件中的post_asset_folder 选项设为 true 】是必须的！理论上既然没用hexo new xxx指令，文件夹也是我自己新建的，这一步设置的意义似乎并不存在，但是后文介绍的插件必须在post_asset_folder 选项设为 true的情况下才能生效——<em><strong>本人亲测，大家记住这么设置即可！</strong></em></p><h5 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h5><p>本次的下载路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs npm">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>使用本插件需要修改路径：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">原来是：!<span class="hljs-selector-attr">[图片描述]</span>（包名/NO.<span class="hljs-number">01.001</span><span class="hljs-selector-class">.jpg</span>）<br>现在是：!<span class="hljs-selector-attr">[图片描述]</span>（NO.<span class="hljs-number">01.001</span><span class="hljs-selector-class">.jpg</span>）<br></code></pre></td></tr></table></figure><p>修改路径即可</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署</title>
    <link href="/2022/06/16/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/06/16/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="使用GitHub-Pages-Hexo搭建个人博客网站"><a href="#使用GitHub-Pages-Hexo搭建个人博客网站" class="headerlink" title="使用GitHub Pages + Hexo搭建个人博客网站"></a>使用GitHub Pages + Hexo搭建个人博客网站</h1><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><ol><li><p><strong>GitHub账号</strong><br>需要有一个GitHub账号，没有的话到 <a href="https://github.com/">官网</a> 申请一个。注册很简单，不懂的话可以参考 <a href="https://github.com/join">GitHub申请账号</a>。</p></li><li><p><strong>安装Git</strong><br>在自己电脑上安装好Git，Hexo部署到GitHub时要用。网上找篇教程或者参考 <a href="https://git-scm.com/book/zh/v2">Git安装(Windows)</a>。</p></li><li><p><strong>安装NodeJS</strong><br>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。网上找篇教程或者参考 <a href="https://nodejs.org/zh-cn/">NodeJS安装及配置(Windows)</a>。</p></li></ol><h2 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h2><p>在GitHub上创建一个新的代码仓库用于保存我们的网页。</p><ol><li><p>点击<code>Your repositories</code>，进入仓库页面。</p></li><li><p>点击<code>New</code>按钮，进入仓库创建页面。</p></li><li><p>填写仓库名，格式必须为&lt;用户名&gt;.github.io，然后点击<code>Create repository</code>。</p></li><li><p>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。</p></li><li><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>GitHub Pages中找到我们主页的地址为 <code>https://&lt;用户名&gt;.github.io/</code></p><p>浏览器中访问，展示成功。</p><p>这里创建的网页是非常简陋的，只是为了演示下GitHub Pages的使用方式。</p><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>我们采用Hexo来创建我们的博客网站，Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/">官网</a>。</p><ol><li><p><strong>安装 Hexo</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p><strong>查看版本</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo -v<br></code></pre></td></tr></table></figure></li><li><p><strong>创建一个项目 hexo-blog 并初始化</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog<br>npm install<br></code></pre></td></tr></table></figure></li><li><p><strong>本地启动</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo g<br>hexo server<br></code></pre></td></tr></table></figure></li></ol><p>浏览器访问 <code>http://localhost:4000</code>，页面默认主图风格如下。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p>Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，<a href="https://hexo.io/themes/">官网主题</a>。</p><p>这里介绍两个主题的使用方法，Next 和 Fluid，个人比较喜欢Fluid，后面章节的功能也是以 Fluid 为基础进行讲解的。</p><h3 id="1-NexT-主题"><a href="#1-NexT-主题" class="headerlink" title="1. NexT 主题"></a>1. NexT 主题</h3><p><strong>安装主题</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> hexo-blog<br>git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure><h2 id="使用-NexT-主题"><a href="#使用-NexT-主题" class="headerlink" title="使用 NexT 主题"></a>使用 NexT 主题</h2><ol><li><p><strong>安装主题</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> hexo-blog<br>git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 NexT 主题</strong></p><p> 打开 <code>_config.yml</code> 文件，该文件为站点配置文件。</p><p> 将主题修改为 <code>next</code>：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure></li><li><p><strong>本地启动</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-Fluid主题"><a href="#2-Fluid主题" class="headerlink" title="2. Fluid主题"></a>2. Fluid主题</h2><p>以下安装步骤摘自 <a href="https://hexo.fluid-dev.com/">Fluid官网</a></p><ol><li><p><strong>安装主题</strong></p><p> 下载最新 release 版本解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p></li><li><p><strong>指定主题</strong></p><p> 修改 Hexo 博客目录中的 <code>_config.yml</code>：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建「关于页」</strong></p><p> 首次使用主题的「关于页」需要手动创建：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new page about<br></code></pre></td></tr></table></figure><p> 创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p> 修改后的文件示例如下：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br></code></pre></td></tr></table></figure></li><li><p><strong>本地启动</strong></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p> 浏览器访问 <code>http://localhost:4000</code>，Fluid主题风格页面如下。</p></li></ol><h2 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h2><p>修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》：</p><p>hexo new post 测试文章</p><p>执行完成后在 <code>source/_posts</code> 目录下生成了一个 <code>md</code> 文件和一个同名的资源目录（用于存放图片）。</p><p>在资源目录 <code>测试文章</code> 中放一张图片 <code>test.png</code>。</p><p>在 <code>测试文章.md</code> 中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为 Markdown 语法，第三种和前两种图片存放位置不一样，是将图片放在 <code>source/images</code> 目录下。这三种写法在 <code>md</code> 文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><hr><p>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:</p><ul><li>原创<br>categories:</li><li>Java</li></ul><hr><p>这是一篇测试文章</p><p><img src="/2022/06/16/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p><p>本地启动</p><p>hexo g -d<br>hexo s</p><h2 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h2><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><ol><li><strong>浏览器tab页名称</strong> 修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</li><li><strong>博客标题</strong> 主题目录 <code>themes/fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</li><li><strong>主页正中间的文字</strong> 主题目录 <code>themes/fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</li></ol><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
